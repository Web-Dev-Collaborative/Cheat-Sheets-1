---
title: ES6 Cheat Sheet
hide_title: true
excerpt: lorem-ipsum
sections:
  - title: lorem-ipsum
    section_id: lorem-ipsum
    image_alt: lorem-ipsum
    content: "## Quick Access Links&#xA;&#xA;\n\n1.  [Basics](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#basics)\n\n    1.  [Primitives](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#primitives)\n\n    2.  [Operators](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#operators)\n\n2.  [More Basic Syntax](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#syntax)\n\n    1.  [Variables](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#variables)\n\n    2.  [Arrays](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#arrays)\n\n    3.  [Logic and Control Structures](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#logic)\n\n3.  [Objects and Functions](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#objects-and-functions)\n\n    1.  [Objects](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#objects)\n\n    2.  [Functions](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#functions)\n\n    3.  [Bind, Call and Apply](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#bind)\n\n4.  [Function Execution, Variable Scope, Closures & Callbacks](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#execution)\n\n    1.  [Hoisting](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#hoisting)\n\n    2.  [Scope Chain](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#scope-chain)\n\n    3.  [Closures](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#closures)\n\n    4.  [Callbacks](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#callbacks)\n\n5.  [Object-Oriented JS and Prototypal Inheritance](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#object-oriented)\n\n    1.  [Constructors](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#constructors)\n\n    2.  [Prototypes](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#prototypes)\n\n    3.  [Prototypal Inheritance](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#prototypal-inheritance)\n\n    4.  [Built-In Constructors](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#built-in)\n\n6.  [Bugs and Error Handling](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#bugs)\n\n7.  [New ES6 stuff](https://github.com/krishnr/JavaScript-cheat-sheet/blob/master/README.md#es6)\n\nTODO: Add 8. Useful Libraries (LoDash, jQuery), 9. Javascript in the browser, 10. NodeJS\n\n\n\n## 1. Basics\n\n**Everything**\_in JS is either an object or a primitive.\n\n\n\n### i. Primitives: Number, String, Boolean (and some special ones)\n\n\n\n### ii. Operators aka weirdly written functions\n\n\n\n## 2. More Basic Syntax\n\n\n\n### i. Variables\n\n\n\n### ii. Arrays\n\n\n\n### iii. Logic and Control Structures\n\n\n\n## 3. Objects and Functions\n\n\n\n### i. Objects\n\nAn object is simply an unordered collection of key-value pairs.\n\n\n\n### ii. Functions\n\nFunctions are special kinds of objects! Functions can have their own methods and properties just like other objects, but they're rarely used in that way.\n\nRemember, functions in JS are first-class. Meaning they can be assigned and passed just like any other variable can.\n\nFunctions are special in that they have an optional name property and a code property (which is the body of the function that actually does stuff). The function's code is executed by the invocation operator\_().\n\nFunction objects don't even have to be declared with a name - you can write an\_**anonymous function**\_definition directly into the arguments of another.\n\nThis has led to a common pattern of\_**\"immediately-executing anonymous functions\"**, which prevent temporary variables from leaking into the global scope. The function expression is wrapped in parenthesis and then is invoked using\_()\n\nAn important distinction: primitives\_**Pass by Value**\_while objects\_**Pass by Reference**\n\nThe\_this\_keyword within methods, always refers to the object that the method is tied to. However, if the method has an inner function, its\_this\_refers to the global object. Some regard this as a bug in JS, so the good practice is to create and use a variable called\_self.\n\n\n\n### iii. Bind, Call and Apply\n\nFunctions that aren't tied to objects can use\_this\_and still be useful. Consider this example.\n\nTo use speak, we need to use the .bind, .call or .apply methods, which are available to\_**all**\_functions. The first parameter of these functions is the object which becomes\_this\_within the function.\n\nThe call and apply methods allow us to do something called\_**Function Borrowing**.\n\nThe bind method allows us to do\_**Function Currying**.\n\n\n\n## 4. Function Execution, Variable Scope, Closures & Callbacks\n\nA few important concepts:\n\n*   **Global**\_means not inside a function. The global object is 'window' in browsers.\n\n*   The\_**Lexical Environment**\_is where something sits physically in the code\n\n*   **'this'**\_is a reference to the object that the currently running method is tied to (by default it's tied to the global object)\n\n*   The\_**Execution Context**\_consists of the environment (state of variables) of the function currently being evaluated. It also includes 'this' and a reference to the outer environment (aka what object is sitting outside this function\_*lexically*)\n\n*   The\_**Execution Stack**\_or\_**Call Stack**\_is the \"stack\" of execution contexts with the global execution context being the bottommost. When the program flow enters a function, a new execution context is popped onto the call stack, and when the function returns, it is popped off.\n\n\n\n### i. Hoisting\n\nBefore actually executing any of the code, the JS engine first looks at all the variable declarations and function statements and sets aside some memory space for them effectively moving them to the top of the code. This is known as\_**hoisting**.\n\nJS is always synchronous (executing code 1 line at a time and in-order) and single-threaded (only 1 command at a time). However, jQuery, event handlers and AJAX calls make use of callbacks which appear to run asynchronously. AJAX calls are delegated off to a different part of the browser (outside the JS engine) which is why they are run asynchronously. When the call returns, or if there's a user click, then these events fill up the Event Queue. The JS Engine only handles the Event Queue when the Execution Stack is empty.\n\n\n\n### ii. Scope Chain\n\nTo find a variable when functions are running, JS looks further than just the variable environment of the currently executing context, it also looks at the outer environment (the environment to which this function is\_*lexically*\_attached). This process continues looking all the way down to the global environment in a process known as the \\_*scope chain*.\n\n\n\n### iii. Closures\n\nOne of JS's most powerful features is\_**closures**. Whenever a function is nested within another function, the inner function has access to all the outer function's variables even after the outer function exits. After the outer function exits, it is popped off the Execution Stack, however if any of its variables are referenced in the inner function, then those variables are \"closed into\" the inner function's Execution Context and are accessible by the inner function.\n\n\n\n### iv. Callbacks\n\n**Callbacks**\_are simply functions passed as arguments to other functions to be run when the other functions are finished.\n\n\n\n## 5. Object-Oriented JS and Prototypal Inheritance\n\n\n\n### i. Function Constructors\n\nWhen you call a function with the\_new\_keyword, a new object is created in memory, and is made available to the function via the\_this\_keyword. Functions designed to be called like that are called constructors.\n\n\n\n### ii. Prototypes\n\nEvery JavaScript object has a 'prototype' property, which is simply a reference to another object. When you go to access a property that doesn't exist on the actual object, the interpreter will look at its prototype. If it doesn't exist on the prototype, it'll look at the prototype's prototype. It will keep looking down this\_**prototype chain**\_until it hits the base object Object, which doesn't have a prototype.\n\n\n\n### iii. Prototypal Inheritance aka setting prototypes of new objects\n\nAccessing\_\\__proto\\_\\_\_is non-standard, and there are no standard ways to change the prototype of an existing object. However, there are two ways to create a new object with a given prototype.\n\nEvery JS function also has a property called 'prototype'. When used as a normal function, the 'prototype' property is not used. Only when functions are used as constructors with the\_new\_keyword, the 'prototype' sets the prototype of the object being created.\n\n\n\n### iv. Built-In Constructors\n\n**Polyfilling**\_takes advantage of the fact that we can modify the built-in prototypes to implement newer features of JavaScript in an older subset of JavaScript, so that they can be used in older environments such as outdated browsers.\n\n\n\n## 6. Bugs and Error Handling\n\n\n\n## 7. New ES6 stuff\n\n### Arrows\n\nArrows are a function shorthands for anonymous functions used with the\_=>\_syntax. They pass the outside lexical scope (ie.\_this) to the function.\n\n### Classes\n\nObject-oriented syntactic sugar for the prototypal inheritance pattern.\n\n### String Interpolation\n\n### let\_and\_const\n\nlet\_is like\_var\_except it is block-scoped. Variables declared with\_const\_can only be assigned once.\n\n### Generator\n\nFunctions that can be paused using the\_yield\_keyword and restarted from the outside.\_yield \\__\\__\\_\_is called a \"yield expression\" which gets evaluated with whatever value we send in when we restart the generator.\_yield\_is making a request for a value.\n\nGenerators are useful because they return (i.e. create) iterators. In turn, an iterator, an object with a\_next\_method, actually executes the body of generators. The\_next\_method, when repeatedly called, partially executes the corresponding generator, gradually advancing through the body until a\_yield\_keyword is hit.\n\nThe\_next\_method of an iterator returns an object with a\_value\_property and a\_done\_property, as long as the body of the corresponding generator has not\_returned. The\_value\_property refers the value\_yielded or\_returned. The\_done\_property is\_false\_up until the generator body\_returns, at which point it is\_true. If the\_next\_method is called after\_done\_is\_true, an error is thrown.\n\n### Maps, Sets, WeakMap, WeakSet\n\nA Map is an object for which the keys can be any arbitrary object. A Set is a data structure which contains a finite set of elements, each occurring only once. WeakMaps and WeakSets provide leak-free object-key’d side tables. The JavaScript virtual machine periodically frees memory allocated to objects no longer in scope. An object is no longer in scope if there is no chain of references from the current scope leading to it.\n\n### Promises\n\nPromises are a library for asynchronous programming. Promises are a first class representation of a value that may be made available in the future. A Promise is in one of these states:\n\n*   pending: initial state, not fulfilled or rejected.\n\n*   fulfilled: successful operation\n\n*   rejected: failed operation.\n\n*   settled: the Promise is either fulfilled or rejected, but not pending.\n\n### Modules\n\n### Proxy\n\nProxy object is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc).\n"
    actions: []
    type: section_content
seo:
  title: ''
  description: ''
  robots: []
  extra: []
template: advanced
---
